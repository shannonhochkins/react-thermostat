{"mappings":"AMkFA;IACE,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,KAAK,CAAC,EAAE,MAAM,CAAC;CAChB;AAED;IACE,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,MAAM,CAAC,EAAE,YAAY,CAAC;CACvB;AAED;IACE,MAAM,CAAC,EAAE,MAAM,EAAE,CAAC;IAClB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,OAAO,CAAC,EAAE;QACR,OAAO,CAAC,EAAE,OAAO,CAAC;QAClB,KAAK,CAAC,EAAE,MAAM,CAAC;QACf,KAAK,CAAC,EAAE,MAAM,CAAC;QACf,IAAI,CAAC,EAAE;YACL,KAAK,CAAC,EAAE,MAAM,CAAC;YACf,MAAM,CAAC,EAAE,MAAM,CAAC;YAChB,SAAS,CAAC,EAAE,MAAM,CAAC;SACpB,CAAC;QACF,GAAG,CAAC,EAAE;YACJ,KAAK,CAAC,EAAE,MAAM,CAAC;YACf,MAAM,CAAC,EAAE,MAAM,CAAC;YAChB,SAAS,CAAC,EAAE,MAAM,CAAC;SACpB,CAAA;KACF,CAAA;CACF;AAED;IACE,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,KAAK,EAAE,MAAM,CAAC;IACd,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,QAAQ,EAAE,CAAC,KAAK,EAAE,MAAM,KAAK,IAAI,CAAC;IAClC,MAAM,CAAC,EAAE,WAAW,CAAC;IACrB,QAAQ,CAAC,EAAE,OAAO,CAAC;IACnB,KAAK,CAAC,EAAE,UAAU,CAAC;CACpB;AAED,2BAA2B,EACzB,IAAU,EACV,GAAO,EACP,GAAS,EACT,KAAK,EACL,WAAW,EACX,MAAM,EAAE,WAAW,EACnB,KAAK,EAAE,UAAU,EACjB,QAAQ,EACR,QAAQ,GACT,EAAE,eAAe,eA8LjB","sources":["src/src/constants.ts","src/src/utils.ts","src/src/arc.ts","src/src/dialLines.tsx","src/src/thermometer.tsx","src/src/handle.tsx","src/src/index.tsx","src/index.tsx"],"sourcesContent":[null,null,null,null,null,null,null,"import React, { useEffect, useRef, useState } from \"react\";\nimport styled from '@emotion/styled';\nimport {\n  angleToPosition,\n  positionToAngle,\n  valueToAngle,\n  angleToValue,\n  merge,\n} from \"./utils\";\nimport { drawArc } from \"./arc\";\nimport { DialLines } from './dialLines';\nimport { Thermometer as ThermometerBase } from './thermometer';\nimport { Handle, DEFAULT_HANDLE_COLORS } from './handle';\nimport { HEIGHT_MULTIPLIER, THICKNESS_DIVISOR, CANVAS_WIDTH, CANVAS_HEIGHT } from './constants';\n\nconst Wrapper = styled.div`\n  position: relative;\n`;\n\nconst ColorPicker = styled.canvas`\n  position: absolute;\n  z-index: -1;\n  visibility: hidden;\n`;\n\ninterface HandleContainerProps {\n  size: number;\n  handleSize: number;\n}\n\nconst HandleContainer = styled.div<HandleContainerProps>`\n  position: absolute;\n  z-index: 3;\n  bottom: 0;\n  left: 0;\n  width: ${props => props.size}px;\n  height: ${props => props.size}px;\n  margin-bottom: -${props => props.handleSize -3}px;\n  margin-left: -${props => props.handleSize}px;\n`;\n\n\nconst Thermometer = styled(ThermometerBase)<{\n  color: string;\n  handleSize: number;\n}>`\n  color: ${props => props.color};\n  font-family: \"Kanit\", sans-serif;\n  font-weight: 100;\n`;\n\ninterface GradientProps {\n  width: number;\n  height: number;\n}\nconst Gradient = styled.div<GradientProps>`\n  width: ${props => props.width}px;\n  height: ${props => props.height}px;\n`;\n\nconst Arc = styled.svg`\n  position: relative;\n`;\n\nconst HANDLE_DEFAULTS = {\n  colors: DEFAULT_HANDLE_COLORS\n}\nconst TRACK_DEFAULTS = {\n  colors: ['#cfac48', '#cd5401'],\n  markers: {\n    enabled: true,\n    every: 5,\n    count: 60,\n    main: {\n      color: 'black'\n    },\n    sub: {\n      color: 'rgba(0,0,0,0.8)'\n    }\n  }\n}\n\nexport interface HandleColors {\n  handle?: string;\n  icon?: string;\n  pulse?: string;\n}\n\nexport interface HandleProps {\n  size?: number;\n  colors?: HandleColors;\n}\n\ninterface TrackProps {\n  colors?: string[];\n  thickness?: number;\n  markers?: {\n    enabled?: boolean;\n    every?: number;\n    count?: number;\n    main?: {\n      color?: string;\n      length?: number;\n      thickness?: number;\n    };\n    sub?: {\n      color?: string;\n      length?: number;\n      thickness?: number;\n    }\n  }\n}\n\ninterface ThermostatProps {\n  size?: number;\n  min?: number;\n  max?: number;\n  value: number;\n  valueSuffix?: string;\n  onChange: (value: number) => void;\n  handle?: HandleProps;\n  disabled?: boolean;\n  track?: TrackProps;\n};\n\nexport function Thermostat({\n  size = 200,\n  min = 0,\n  max = 100,\n  value,\n  valueSuffix,\n  handle: handleInput,\n  track: trackInput,\n  onChange,\n  disabled,\n}: ThermostatProps) {\n  const handle = merge({\n    ...HANDLE_DEFAULTS,\n    size: size / 15\n  }, handleInput || {});\n  const track = merge({\n    ...TRACK_DEFAULTS,\n    thickness: size / 10,\n  }, trackInput || {});\n  const _svgRef = useRef<SVGSVGElement>(null);\n  const _handleRef = useRef<HTMLDivElement>(null)\n  const _canvasRef = useRef<HTMLCanvasElement>(null);\n  const [color, setColor] = useState('transparent');\n  const trackInnerRadius = size / 2 - track.thickness;\n  const thermoOffset = (track.thickness + (track.thickness / THICKNESS_DIVISOR));\n  const height = size * HEIGHT_MULTIPLIER + thermoOffset;\n  const handleAngle = valueToAngle({\n    value,\n    min,\n    max,\n  });\n  const handlePosition = angleToPosition(\n    handleAngle,\n    trackInnerRadius + track.thickness / 2,\n    size\n  );\n  const controllable = !disabled && Boolean(onChange);\n\n  useEffect(() => {\n    const canvasRef = _canvasRef.current;\n    if (canvasRef) {\n      const ctx = canvasRef.getContext('2d');\n      if (ctx) {\n        const gradient = ctx.createLinearGradient(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        track.colors?.forEach((color, index) => {\n          const offset = index === 0 ? 0.2 : index === track.colors.length - 1 ? 0.8 : (index / (track.colors.length - 1));\n          gradient.addColorStop(offset, color)\n        });\n        ctx.fillStyle = gradient;\n        ctx.rect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        ctx.fill();\n      }\n    }\n  }, [track.colors]);\n\n  useEffect(() => {\n    getColourFromValue();\n  }, [value, track.colors]);\n\n  if (value < min || value > max) {\n    throw new Error(`\"value\" should be between ${min} and ${max}`);\n  }\n\n  function onMouseEnter(ev: React.MouseEvent<HTMLDivElement>) {\n    if (ev.buttons === 1) {\n      // The left mouse button is pressed, act as though user clicked us\n      onMouseDown(ev);\n    }\n  };\n\n  function onMouseDown(ev: React.MouseEvent<HTMLDivElement>) {\n    const handleRef = _handleRef.current;\n    if (handleRef) {\n      handleRef.addEventListener(\"mousemove\", processSelection);\n      handleRef.addEventListener(\"mouseleave\", removeMouseListeners);\n      handleRef.addEventListener(\"mouseup\", removeMouseListeners);\n    }\n    processSelection(ev);\n  };\n\n  function removeMouseListeners() {\n    const handleRef = _handleRef.current;\n    if (handleRef) {\n      handleRef.removeEventListener(\"mousemove\", processSelection);\n      handleRef.removeEventListener(\"mouseleave\", removeMouseListeners);\n      handleRef.removeEventListener(\"mouseup\", removeMouseListeners);\n    }\n  };\n\n  function getColourFromValue() {\n    const canvasRef = _canvasRef.current;\n    if (canvasRef) {\n      const ctx = canvasRef.getContext('2d');\n      // input value percentage between min and max\n      if (ctx) {\n        const percent = ((value - min) * 100) / (max - min);\n        const scaling = (CANVAS_WIDTH - 1) * percent / 100;\n        const v = ctx.getImageData(scaling, 1, 1, 1).data; \n        setColor(`rgb(${v[0]},${v[1]},${v[2]})`);\n      }\n    }\n  }\n\n  function processSelection(ev: React.MouseEvent<HTMLDivElement> | MouseEvent) {\n    if (!onChange || disabled) {\n      // Read-only, don't bother doing calculations\n      return;\n    }\n    const svgRef = _svgRef.current;\n    if (!svgRef) {\n      return;\n    }\n    // Find the coordinates with respect to the SVG\n    const svgPoint = svgRef.createSVGPoint();\n    const x = ev.clientX;\n    const y = ev.clientY;\n    svgPoint.x = x;\n    // offset the Y by the size of the thermometer difference\n    svgPoint.y = y - (height - size);\n    const coordsInSvg = svgPoint.matrixTransform(\n      svgRef.getScreenCTM()!.inverse()\n    );\n    const angle = positionToAngle(coordsInSvg, size);\n    onChange(angleToValue({\n      angle,\n      min,\n      max,\n    }));\n  };\n  const arc = drawArc({\n    innerRadius: trackInnerRadius,\n    thickness: track.thickness,\n    svgSize: size,\n  });\n  return <Wrapper>\n    <ColorPicker width={CANVAS_WIDTH} height={CANVAS_HEIGHT} ref={_canvasRef}></ColorPicker>\n    <Arc\n      width={size}\n      height={height}\n      ref={_svgRef}\n    >\n      <Thermometer\n        handleSize={handle.size}\n        textColor={'rgba(0,0,0,0.9)'}\n        color={color}\n        value={Number(value.toFixed(0))} \n        min={min}\n        max={max}\n        suffix={valueSuffix}\n        thickness={track.thickness / THICKNESS_DIVISOR}\n        size={size} />\n      <foreignObject x=\"0\" y={height - size} width={size} height={size} clipPath=\"url(#clip)\">\n        <Gradient \n          width={size}\n          height={size}\n          style={{\n            backgroundImage: `conic-gradient(from 0deg, ${[...track.colors || []].reverse().map((color, index) => {\n              const offset = index === 0 ? 20 : index === track.colors.length - 1 ? 80 : (index / (track.colors.length - 1)) * 100;\n              return `${color} ${offset}%`;\n            }).join(', ')}`\n          }} />\n      </foreignObject>\n      <mask id=\"arc-mask\">\n        <path d={arc} fill=\"white\" />\n      </mask>\n      <clipPath id=\"clip\">\n        <path d={arc} />\n      </clipPath>\n      {track.markers.enabled && <g transform={`translate(0, ${height - size})`}>\n        <DialLines\n          ticks={{\n            every: track.markers.every,\n            count: track.markers.count,\n            main: {\n              thickness: 2,\n              length: track.thickness / 4,\n              ...track.markers.main\n            },\n            sub: {\n              thickness: 1,\n              length: track.thickness / 8,\n              ...track.markers.sub\n            }\n          }}\n          mask=\"arc-mask\"\n          size={size}\n          />\n      </g>}\n    </Arc>\n    {!disabled && <HandleContainer\n      onMouseDown={onMouseDown}\n      onMouseEnter={onMouseEnter}\n      onClick={(ev) => {\n        // we could determine how close we are to the track here and only allow events when they're closer to the\n        // arc, later job\n        return controllable && ev.stopPropagation()\n      }} ref={_handleRef} handleSize={handle.size} size={size + (handle.size * 2)}>\n      <Handle colors={handle.colors} x={handlePosition.x} y={handlePosition.y} size={size} handleSize={handle.size} />\n    </HandleContainer>}\n  </Wrapper>\n}\n"],"names":[],"version":3,"file":"types.d.ts.map"}